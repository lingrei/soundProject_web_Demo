<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>éŸ³æºé¡¹ç›® - MVP V18.1 (Final Polish)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* --- æ ·å¼ (åŸºäº V8.3/V16.0) --- */
        :root { --bg-color: #222; --panel-color: #333; --highlight: #4caf50; --text-color: #eee; --gold-color: #ffd700; --cpu-used: #ff9800; --item-blue: #64b5f6; --border: 1px solid #555; --playhead-color: #ff5252; --lose-color: #ff5252; }
        /* Item Type Colors */
        :root { --c-score: #ffd700; --c-support: #00e5ff; --c-engine: #d500f9; }

        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; margin: 0; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        
        .container { width: 98vw; max-width: 1600px; height: 95vh; display: grid; grid-template-columns: 220px 1fr 260px; grid-template-rows: 70px 1fr 180px; gap: 8px; background: #2a2a2a; padding: 10px; box-shadow: 0 0 50px rgba(0,0,0,0.8); border-radius: 8px; }
        
        /* Header Layout - Absolute Centering */
        .header { grid-column: 1 / -1; grid-row: 1 / 2; background: var(--panel-color); border: var(--border); border-radius: 4px; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; position: relative; }
        
        /* Left: Clear Button */
        .header-left { display: flex; align-items: center; justify-content: flex-start; min-width: 100px; z-index: 10; } 
        .btn-clear { background: #d32f2f; color: white; border: none; padding: 8px 16px; font-size: 12px; font-weight: bold; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px; transition: background 0.2s; white-space: nowrap; }
        .btn-clear:hover { background: #f44336; }
        
        /* Center: Stats (Absolute Positioned) */
        .stat-group { 
            position: absolute; 
            left: 50%; 
            top: 50%; 
            transform: translate(-50%, -50%); 
            display: flex; 
            gap: 20px; 
            align-items: center; 
            justify-content: center; 
            z-index: 5; 
        }
        .stat-block { display: flex; flex-direction: column; align-items: center; background: #222; padding: 5px 15px; border-radius: 8px; border: 1px solid #444; min-width: 90px; }
        .stat-label { font-size: 10px; color: #aaa; margin-bottom: 2px; }
        .stat-val { font-size: 18px; font-weight: bold; color: white; }
        .gold-display { color: var(--gold-color); text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
        
        /* Right: Debug */
        .header-right { display: flex; align-items: center; justify-content: flex-end; min-width: 100px; z-index: 10; }
        .debug-panel { display: flex; gap: 4px; align-items: center; background: #111; padding: 4px 8px; border: 1px solid #444; border-radius: 4px; }
        .debug-text { color: #666; font-size: 10px; font-weight: bold; margin-right: 2px; }
        .debug-input { width: 40px; background: #333; color: white; border: 1px solid #555; padding: 2px; font-size: 11px; text-align: center; }
        .debug-btn { background: #555; color: white; border: none; padding: 3px 8px; font-size: 10px; cursor: pointer; border-radius: 2px; }
        .debug-btn:hover { background: #777; }
        
        .cpu-container { width: 180px; display: flex; flex-direction: column; gap: 2px; }
        .cpu-track { height: 10px; background: #111; border-radius: 6px; overflow: hidden; border: 1px solid #444; }
        .cpu-fill { height: 100%; width: 0%; background: var(--highlight); transition: width 0.3s; }
        .cpu-fill.danger { background: #f44336; }
        
        .inventory-panel { grid-column: 1 / 2; grid-row: 2 / 3; background: var(--panel-color); border: var(--border); display: flex; flex-direction: column; overflow: hidden; }
        .panel-header { background: #222; padding: 8px; font-weight: bold; text-align: center; border-bottom: var(--border); font-size: 13px; }
        .inventory-list { flex: 1; padding: 8px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; }
        .inv-item { background: #444; padding: 6px 8px; border-radius: 4px; cursor: pointer; border: 1px solid transparent; transition: all 0.2s; border-left-width: 4px; position: relative; }
        .inv-item:hover { background: #505050; } 
        .inv-item.selected { background: #2e4e30; box-shadow: 0 0 8px var(--highlight); border-color: var(--highlight); }
        .inv-item.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .inv-item b { display: block; margin-bottom: 2px; font-size: 12px; }
        .inv-meta { font-size: 10px; color: #aaa; display: flex; justify-content: space-between; }
        
        .daw-container { grid-column: 2 / 3; grid-row: 2 / 3; display: flex; flex-direction: column; background: #151515; border: var(--border); padding: 5px; height: 100%; box-sizing: border-box; }
        .timeline-header { display: flex; height: 20px; border-bottom: 1px solid #444; margin-bottom: 0; flex-shrink: 0; }
        .ruler-beat { flex: 1; border-right: 1px solid #333; font-size: 10px; color: #666; padding-left: 4px; line-height: 20px; }
        .track-area { flex: 1; display: flex; flex-direction: column; gap: 0; border: 1px solid #333; height: 100%; position: relative; overflow: hidden; }
        .track { flex: 1; background: #1a1a1a; border-bottom: 1px solid #333; display: flex; position: relative; align-items: center; }
        .track:last-child { border-bottom: none; }
        .track.locked { background: repeating-linear-gradient(45deg, #111, #111 10px, #1a1a1a 10px, #1a1a1a 20px); pointer-events: none; opacity: 0.5; }
        .track.locked::after { content: "LOCKED"; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); color: #444; font-weight: bold; font-size: 20px; letter-spacing: 5px; }
        .grid-cell { flex: 1; height: 100%; border-right: 1px solid #252525; cursor: crosshair; }
        .grid-cell:nth-child(4n) { border-right: 1px solid #444; } 
        .grid-cell:nth-child(16n) { border-right: 1px solid #666; }
        .playhead { position: absolute; top: 0; bottom: 0; left: 0; width: 2px; background-color: var(--playhead-color); z-index: 9999; box-shadow: 0 0 10px var(--playhead-color); pointer-events: none; display: none; }
        
        .placed-item { position: absolute; height: 50%; background: var(--item-blue); border-radius: 3px; display: flex; align-items: center; justify-content: center; font-size: 11px; color: black; font-weight: bold; box-shadow: 0 2px 5px rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.2); cursor: pointer; transition: all 0.2s; z-index: 5; overflow: hidden; white-space: nowrap; }
        .placed-item:hover { filter: brightness(1.1); }
        .placed-item.selected-placed { border-color: white; z-index: 20; transform: scale(1.02); }
        .playing-lock .placed-item { cursor: not-allowed; pointer-events: none; }
        .playing-lock .grid-cell { cursor: not-allowed; }
        .placed-item.playing-active { filter: brightness(2.5) contrast(1.5) !important; box-shadow: 0 0 30px white !important; z-index: 50 !important; transform: scale(1.1); }
        
        /* Static Glow */
        .placed-item.glowing-score { box-shadow: inset 0 0 10px var(--c-score); border: 2px solid var(--c-score); background-color: rgba(255,215,0,0.3) !important; }
        .placed-item.glowing-support { box-shadow: inset 0 0 10px var(--c-support); border: 2px solid var(--c-support); background-color: rgba(0,229,255,0.3) !important; }
        .placed-item.glowing-engine { box-shadow: inset 0 0 10px var(--c-engine); border: 2px solid var(--c-engine); background-color: rgba(213,0,249,0.3) !important; }

        .shop-panel { grid-column: 3 / 4; grid-row: 2 / 3; background: var(--panel-color); border: var(--border); display: flex; flex-direction: column; }
        .shop-list { flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        .shop-item { background: #222; padding: 8px; border: 1px solid #444; border-radius: 4px; display: flex; flex-direction: column; gap: 4px; cursor: pointer; transition: background 0.2s; position: relative; }
        .shop-item:active { background: #333; }
        .discount-tag { position: absolute; top: -5px; right: -5px; background: #f44336; color: white; font-size: 10px; padding: 2px 4px; border-radius: 4px; font-weight: bold; transform: rotate(15deg); box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .shop-row-top { display: flex; justify-content: space-between; align-items: center; }
        .shop-row-btm { display: flex; justify-content: space-between; align-items: center; font-size: 10px; color: #888;}
        .btn-buy { background: var(--highlight); border: none; color: white; cursor: pointer; padding: 3px 10px; border-radius: 2px; font-size: 11px; }
        .btn-buy:hover { filter: brightness(1.1); }
        .btn-buy:disabled { background: #444 !important; color: #888 !important; cursor: not-allowed; }
        .shop-controls { padding: 8px; border-top: 1px solid #444; display: flex; flex-direction: column; gap: 6px; background: #252525; }
        .btn-reroll { background: #ff9800; color: black; border: none; padding: 6px; cursor: pointer; font-weight: bold; font-size: 12px; border-radius: 4px; }
        .trade-area { display: flex; gap: 5px; }
        .btn-trade { flex: 1; padding: 8px; border: none; cursor: pointer; font-weight: bold; font-size: 11px; border-radius: 4px; color: white; }
        .btn-cpu { background: #2196f3; display: flex; flex-direction: column; align-items: center; line-height: 1.2; }
        .btn-sell { background: #e53935; display: none; }
        .bottom-panel { grid-column: 1 / -1; grid-row: 3 / 4; display: flex; gap: 10px; padding-top: 5px; position: relative; overflow: hidden; }
        .info-box { background: var(--panel-color); border: var(--border); padding: 10px 15px; border-radius: 4px; overflow-y: auto; transition: filter 0.3s; }
        .info-left { flex: 2; border-left: 4px solid var(--highlight); } 
        .info-right { flex: 1; display: flex; flex-direction: column; justify-content: space-between; border-left: 4px solid #2196f3; padding-left: 15px; }
        
        #skipOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(211, 47, 47, 0.9);
            color: white; font-size: 24px; font-weight: bold; letter-spacing: 2px;
            display: none; justify-content: center; align-items: center;
            cursor: pointer; z-index: 100; text-transform: uppercase;
            transition: opacity 0.2s;
        }
        #skipOverlay:hover { background: rgba(244, 67, 54, 0.95); }
        
        .detail-title { font-size: 16px; color: white; margin-bottom: 5px; font-weight: bold; }
        .detail-meta { font-size: 11px; color: #aaa; margin-bottom: 8px; display: flex; gap: 15px; }
        .detail-desc { font-size: 13px; color: #ccc; line-height: 1.4; background: #222; padding: 8px; border-radius: 4px; }
        
        /* Tooltip */
        .tooltip-ref { color: #4fc3f7; font-weight: bold; cursor: help; border-bottom: 1px dashed #4fc3f7; position: relative; }
        #tooltip { position: fixed; background: #111; border: 1px solid #666; padding: 8px; border-radius: 4px; color: #eee; font-size: 12px; z-index: 9999; display: none; box-shadow: 0 4px 10px rgba(0,0,0,0.5); max-width: 200px; pointer-events: none; }
        .tooltip-key { color: var(--highlight); font-weight: bold; margin-bottom: 4px; display: block; }

        .submit-btn { width: 100%; padding: 10px; background: white; color: black; font-size: 18px; font-weight: bold; border: none; border-radius: 20px; cursor: pointer; transition: transform 0.1s; margin-top: 5px; }
        .submit-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px white; }
        .submit-btn:disabled { background: #555; color: #888; transform: none; box-shadow: none; cursor: wait; }

        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #333; padding: 30px; border-radius: 8px; width: 900px; max-height: 90vh; overflow-y: auto; box-shadow: 0 0 30px black; text-align: center; }
        .card-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
        .card { background: #444; padding: 15px; border: 2px solid #555; cursor: pointer; text-align: left; }
        .card.active { border-color: var(--highlight); background: #2e4e30; }
        table.result-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 13px; }
        table.result-table th { text-align: left; border-bottom: 1px solid #666; padding: 5px; color: #aaa; }
        table.result-table td { padding: 8px 5px; border-bottom: 1px solid #444; }
        .score-val { color: gold; font-weight: bold; }
        /* Tags */
        .buff-tag { display: inline-block; background: #222; padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-right: 4px; border: 1px solid #444; }
        .tag-score { color: var(--c-score); border-color: var(--c-score); }
        .tag-support { color: var(--c-support); border-color: var(--c-support); }
        .tag-engine { color: var(--c-engine); border-color: var(--c-engine); }

        .campaign-status-modal { margin-bottom: 15px; font-size: 16px; color: #aaa; letter-spacing: 1px; display: flex; justify-content: center; gap: 20px; }
        .status-item { display: flex; align-items: center; gap: 5px; }
        .status-hearts { font-size: 24px; letter-spacing: 5px; line-height: 1; }
        .status-dots { display: flex; gap: 4px; }
        .status-dot { width: 12px; height: 12px; border-radius: 50%; background: #444; }
        .status-dot.done { background: var(--highlight); }
        .status-dot.current { border: 2px solid white; transform: scale(1.2); }
    </style>
</head>
<body>

<div id="tooltip"></div>

<div class="container" id="mainContainer">
    <div class="header">
        <div class="header-left">
            <button class="btn-clear" onclick="clearAllItems()">ğŸ—‘ï¸ CLEAR</button>
        </div>
        
        <div class="stat-group">
            <div class="stat-block">
                <div class="stat-label">â˜… CPU</div>
                <div class="cpu-container">
                    <div class="cpu-track"><div class="cpu-fill" id="cpuBar"></div></div>
                    <div style="display:flex; justify-content:space-between; font-size:10px; color:#888;">
                        <span id="cpuText">0</span>
                        <span id="maxCpuText">Max: 12</span>
                    </div>
                </div>
            </div>

            <div class="stat-block">
                <div class="stat-label">ç›®æ ‡ Groove</div>
                <div class="stat-val" id="targetText">360</div>
            </div>

            <div class="stat-block">
                <div class="stat-label">èµ„é‡‘ (G)</div>
                <div class="stat-val gold-display" id="goldText">150</div>
            </div>
        </div>

        <div class="header-right">
            <div class="debug-panel">
                <span class="debug-text">DBG:</span>
                <input type="number" id="dbgGold" class="debug-input" placeholder="G">
                <button class="debug-btn" onclick="debugSetGold()">Set</button>
                <input type="number" id="dbgTarget" class="debug-input" placeholder="Tgt">
                <button class="debug-btn" onclick="debugSetTarget()">Set</button>
            </div>
        </div>
    </div>

    <div class="inventory-panel">
        <div class="panel-header">åº“å­˜ (Inventory)</div>
        <div class="inventory-list" id="inventoryList"></div>
    </div>

    <div class="daw-container">
        <div class="timeline-header"></div>
        <div class="track-area" id="trackArea"></div>
    </div>

    <div class="shop-panel">
        <div class="panel-header">å•†åº— (Shop)</div>
        <div class="shop-list" id="shopList"></div>
        <div class="shop-controls">
            <div class="trade-area">
                <button class="btn-trade btn-cpu" onclick="buyCpu()" id="btnBuyCpu">
                    <span>UP CPU</span>
                    <span style="font-size:10px; color:#ddd;" id="cpuPriceText">50G</span>
                </button>
                <button class="btn-trade btn-sell" onclick="sellSelectedItem()" id="btnSellItem">
                    å‡ºå”® (25G)
                </button>
            </div>
            <button class="btn-reroll" onclick="rerollShop()" id="btnReroll">åˆ·æ–° (10G)</button>
        </div>
    </div>

    <div class="bottom-panel">
        <div id="skipOverlay" onclick="skipPlayback()">â© CLICK TO FAST FORWARD</div>
        <div class="info-box info-left">
            <div class="detail-title" id="detailTitle">å‡†å¤‡å°±ç»ª</div>
            <div class="detail-meta" id="detailMeta"></div>
            <div class="detail-desc" id="detailContent">
                1. V18.1 ä¿®æ­£ï¼šå…¨ä¸­æ–‡ç•Œé¢ä¸è§„èŒƒåŒ–æè¿° <br>
                2. UIä¼˜åŒ–ï¼šCPUå±…ä¸­ï¼ŒDebgé å³ <br>
                3. æ•°å€¼ï¼šNG4å…¬å¼ä¼˜åŒ–ï¼ŒEB2/5ä¸Šé™/æè¿°ä¿®æ­£
            </div>
        </div>
        <div class="info-box info-right">
            <div style="font-size:14px; color:#ccc; line-height:1.8;">
                <b>å½“å‰å…³å¡:</b> <span id="levelNum">Level 1</span><br>
                <b>è½¨é“æ•°é‡:</b> <span id="trackNum">2</span> Tracks
            </div>
            <button class="submit-btn" id="mainSubmitBtn" onclick="runPlaybackSequence()">Submit / ç»“ç®—</button>
        </div>
    </div>
</div>

<div class="modal" id="startScreen" style="display:flex;"><div class="modal-content" style="width: 400px;"><h1>Soundwave</h1><p style="color:#aaa; margin-bottom:30px;">éŸ³ä¹æ„ç­‘ Roguelike MVP Demo</p><button class="submit-btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button></div></div>
<div class="modal" id="resultModal"><div class="modal-content" style="width: 900px;"><h2 id="resTitle">ç»“ç®—æŠ¥å‘Š</h2><div id="campaignStatusContainer" class="campaign-status-modal"></div><h3 id="resOutcome" style="font-size:28px; margin: 5px 0;"></h3><div style="display:flex; justify-content:space-around; margin-bottom:20px;"><div>ç›®æ ‡: <span id="resTargetDisplay" style="font-size:24px;"></span></div><div>æ€» Groove: <span id="resTotalScore" style="font-size:32px; color:gold; font-weight:bold;"></span></div></div><div id="resTableContainer" style="max-height: 400px; overflow-y: auto; margin-bottom: 10px;"></div><div id="resRewardInfo" style="text-align:center; color:#4caf50; font-weight:bold; margin:10px 0;"></div><div style="margin-top:20px; display:flex; gap:20px; justify-content:center;"><button class="submit-btn" style="width:200px; display:none;" id="nextLevelBtn" onclick="nextLevel()">ä¸‹ä¸€å…³</button><button class="submit-btn" style="width:200px; display:none;" id="finishGameBtn" onclick="showVictory()">åŠ å†•æ—¶åˆ»</button><button class="submit-btn" style="width:200px; display:none; background:#d32f2f;" id="retryLevelBtn" onclick="retryLevel()">é‡è¯• (æ¶ˆè€—ç”Ÿå‘½)</button><button class="submit-btn" style="width:200px; display:none; background:#000;" id="dieBtn" onclick="showGameOver()">æ¥å—ç»“å±€</button></div></div></div>
<div class="modal" id="victoryModal"><div class="modal-content" style="width: 500px;"><h1 style="color:gold;">æ­å–œé€šå…³!</h1><p>ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰6ä¸ªå…³å¡çš„æŒ‘æˆ˜ã€‚</p><button class="submit-btn" onclick="location.reload()">å†æ¬¡å¼€å§‹</button></div></div>
<div class="modal" id="gameOverModal"><div class="modal-content" style="width: 500px;"><h1 style="color:#ff5252;">æ¸¸æˆç»“æŸ</h1><p>ä½ çš„ç”Ÿå‘½å€¼å·²è€—å°½ã€‚</p><button class="submit-btn" onclick="location.reload()">é‡å¤´å†æ¥</button></div></div>
<div class="modal" id="poolModal"><div class="modal-content"><h2>å½“å‰æ± å­ (Debug)</h2><div class="card-grid" id="poolGrid"></div><button class="submit-btn" onclick="document.getElementById('poolModal').style.display='none'">ä¿å­˜</button></div></div>

<script>
    const TICKS = 32;
    const TOTAL_TRACKS = 3; 
    const TOTAL_DURATION = 16; 
    const TICK_DURATION = TOTAL_DURATION / TICKS;
    
    const LEVEL_CONFIG = [
        { tracks: 2, target: 324,  reward: 200, poolAdds: ["NG1", "EB2", "EB3", "SB2", "NG3"] },
        { tracks: 2, target: 420,  reward: 250, poolAdds: ["SB3", "EB6"] },
        { tracks: 3, target: 576,  reward: 350, poolAdds: ["SB4", "NG4", "EB4"] },
        { tracks: 3, target: 735,  reward: 450, poolAdds: ["SB5", "EB5"] },
        { tracks: 3, target: 925,  reward: 600, poolAdds: [] },
        { tracks: 3, target: 1200, reward: 0,   poolAdds: [] }
    ];

    let config = { maxCpu: 12, target: 324, activeTracks: 2 };
    let state = {
        inventory: [], placedItems: [], poolIds: [], poolEntryTimes: {}, 
        levelIndex: 0, selectedInvItem: null, shopLocked: false, isPlaying: false,
        gold: 150, cpuPurchasedRound: 0, roundBase: 10, currentShopItems: [],
        ng1PermanentStacks: 0, lastRoundReward: 0, lives: 3
    };

    // V18.1 Updated Descriptions & Specs
    const DB = [
        { id: "SB1", name: "åº•é¼“", len: 4, cpu: 1, base: 20, type: "score", color: "#ffecb3", price: 75, rarity: 1, desc: "è§¦å‘æ—¶è·å¾— 20 Grooveã€‚<br>è‹¥æ”¾ç½®åœ¨ [å¼ºæ‹] ä¸Šï¼Œé¢å¤–è·å¾— 10 Grooveã€‚" },
        { id: "SB2", name: "ä¾§é“¾", len: 4, cpu: 1, base: 0, type: "support", color: "#b2ebf2", price: 75, rarity: 1, desc: "ä½¿æ‰€æœ‰ [åŒæ­¥] é“å…· Groove +50%ã€‚<br>è‹¥æ”¾ç½®åœ¨ [å¼ºæ‹] ä¸Šï¼Œè¯¥å¢å¹…æ•ˆæœé¢å¤– +25%ã€‚" },
        { id: "SB3", name: "é‡éŸ³æ ‡è®°", len: 4, cpu: 2, base: 0, type: "support", color: "#80deea", price: 100, rarity: 2, desc: "[åŒè½¨] ä½¿ ä¸‹ä¸€ä¸ª é“å…· Groove +100%ã€‚<br>è‹¥æ”¾ç½®åœ¨ [å¼ºæ‹] ä¸Šï¼Œä¸‹ä¸€ä¸ª é“å…·å°†è¢«è§†ä¸º åœ¨[å¼ºæ‹]è§¦å‘ã€‚" },
        { id: "SB4", name: "ä¸»æ—¶é’Ÿ", len: 4, cpu: 4, base: 0, type: "engine", color: "#e1bee7", price: 150, rarity: 3, desc: "è‹¥ è§¦å‘å‰ å·²è§¦å‘è‡³å°‘ 5æ¬¡ [å¼ºæ‹] æ•ˆæœï¼š<br>åç»­ è§¦å‘çš„æ‰€æœ‰ [å¼ºæ‹] é“å…· Groove x 1.5ã€‚" },
        { id: "SB5", name: "é‡åŒ–å™¨", len: 8, cpu: 4, base: 0, type: "engine", color: "#ce93d8", price: 150, rarity: 3, desc: "è‹¥æ”¾ç½®åœ¨ [å¼ºæ‹] ä¸Šï¼Œå…¨åœºæ‰€æœ‰çš„ [å¼±æ‹] å‡è¢«è§†ä¸º [å¼ºæ‹]ã€‚" },
        { id: "EB1", name: "ä¼‘æ­¢ç¬¦", len: 2, cpu: 1, base: 14, type: "score", color: "#ffe082", price: 75, rarity: 1, desc: "è§¦å‘æ—¶è·å¾— 14 Grooveã€‚<br>è‹¥ [åŒè½¨]å‰ä¸€ä¸ª é“å…·ä¸è‡ªèº«é—´éš” â‰¥ 4 [ç©ºæ‹]ï¼Œé¢å¤–è·å¾— 20 Grooveã€‚" },
        { id: "EB2", name: "é¢„å»¶æ—¶", len: 2, cpu: 1, base: 0, type: "support", color: "#4dd0e1", price: 75, rarity: 1, desc: "[åŒè½¨] ä½¿ ä¸‹ä¸€ä¸ª é“å…· Groove +35%ã€‚<br>è‡ªèº«ä¸ä¸‹ä¸€ä¸ªé“å…·æ¯é—´éš” 1 [ç©ºæ‹]ï¼Œè¯¥å¢å¹…æ•ˆæœ +12.5%ï¼ˆä¸Šé™125%ï¼‰ã€‚" },
        { id: "EB3", name: "éš”ç¦»å®¤", len: 4, cpu: 2, base: 0, type: "support", color: "#00bcd4", price: 100, rarity: 2, desc: "ä½¿æ‰€æœ‰ [åŒæ­¥] é“å…· Groove +10ã€‚<br>è‡ªèº« æ¯ä¸ [åŒè½¨] å‰åé“å…·é—´éš” 1 [ç©ºæ‹]ï¼Œä½¿ [åŒæ­¥] é“å…·çš„ Groove +7.5%ï¼ˆä¸Šé™240%ï¼‰ã€‚" },
        { id: "EB4", name: "æ°›å›´é‡‡æ ·", len: 4, cpu: 3, base: 30, type: "score", color: "#ffd54f", price: 150, rarity: 3, desc: "è§¦å‘æ—¶è·å¾— 30 Grooveã€‚<br>è§¦å‘å‰ æ¯å‡ºç° 1 [ç©ºæ‹]ï¼Œè‡ªèº« Groove +5%ã€‚" },
        { id: "EB5", name: "æ—¶é—´æ‹‰ä¼¸", len: 8, cpu: 4, base: 0, type: "engine", color: "#ba68c8", price: 150, rarity: 3, desc: "è®¡ç®—æ‰€æœ‰ [ç©ºæ‹] æ•ˆæœæ—¶ï¼Œ1 [ç©ºæ‹] å°†è¢«è§†ä¸º 2 [ç©ºæ‹]ã€‚" },
        { id: "EB6", name: "é“ºåº•éŸ³è‰²", len: 8, cpu: 2, base: 30, type: "score", color: "#ffca28", price: 100, rarity: 2, desc: "æŒç»­æœŸé—´è·å¾— 30 Grooveã€‚<br>æŒç»­æœŸé—´ å…¨åœºæ¯å­˜åœ¨ 1 [ç©ºæ‹]ï¼Œè‡ªèº« Groove +5%ã€‚" },
        { id: "NG1", name: "ç½‘çº¢å•æ›²", len: 8, cpu: 1, base: 30, type: "score", color: "#cfd8dc", price: 75, rarity: 1, desc: "è§¦å‘æ—¶è·å¾— 30 Grooveã€‚<br>ç¦»åœº: å–å‡ºæ­¤é“å…·æ—¶ï¼ŒåŸºäºå…¶ç´¯è®¡ä¸Šåœºæ¬¡æ•°ï¼Œç«‹å³ ä½¿å•†åº—æ‰€æœ‰é“å…·æ‰“æŠ˜ã€‚" },
        { id: "NG2", name: "å å±‚", len: 4, cpu: 1, base: 20, type: "score", color: "#b0bec5", price: 75, rarity: 1, desc: "è§¦å‘æ—¶è·å¾— 20 Grooveã€‚<br>è‹¥æœ‰å…¶ä»–é“å…· [åŒæ­¥] è§¦å‘ï¼Œé¢å¤–è·å¾— 10 Grooveã€‚" },
        { id: "NG3", name: "ç‹¬å¥æ¨å­", len: 2, cpu: 1, base: 0, type: "support", color: "#90a4ae", price: 100, rarity: 2, desc: "[åŒè½¨] ä½¿ å‰ä¸€ä¸ª å’Œ ä¸‹ä¸€ä¸ª é“å…· Groove +35%ã€‚<br>è‹¥è§¦å‘æ—¶ æ—  å…¶ä»–é“å…· [åŒæ­¥] è§¦å‘ï¼Œè¯¥å¢å¹…æ•ˆæœé¢å¤– +35%ã€‚" },
        { id: "NG4", name: "é™å™ªé—¨", len: 4, cpu: 2, base: 40, type: "score", color: "#78909c", price: 150, rarity: 3, desc: "[åå™¬]: ä½¿æ‰€æœ‰ [åŒæ­¥] é“å…·çš„ Groove å‡åŠã€‚<br>è‡ªèº«è·å¾— Groove = (40 + [åå™¬] çš„æ•°å€¼) x 1.5ã€‚" }
    ];

    // V18.1 Updated Definitions
    const DEFINITIONS = {
        "å¼ºæ‹": "æ¯å°èŠ‚çš„ç¬¬1æ‹ä¸ç¬¬3æ‹ã€‚",
        "å¼±æ‹": "æ¯å°èŠ‚çš„ç¬¬2æ‹ä¸ç¬¬4æ‹ã€‚",
        "åŒè½¨": "å¤„äºåŒä¸€éŸ³è½¨ä¸Šçš„é“å…·ã€‚",
        "åŒæ­¥": "å‚ç›´æ–¹å‘ä¸Šï¼Œä¸è¯¥é“å…·åœ¨åŒä¸€æ—¶é—´ç‚¹è¢«è§¦å‘çš„å…¶ä»–é“å…·ã€‚",
        "æ ¼": "DAWä¸­æœ€å°çš„ç©ºé—´å•ä½ã€‚1æ‹ = 4æ ¼ã€‚",
        "ç©ºæ‹": "éŸ³è½¨ä¸Šæœªè¢«å ç”¨çš„æ ¼å­ã€‚",
        "åå™¬": "å‡å°‘ç›®æ ‡é“å…·çš„åˆ†æ•°ï¼Œå¹¶å°†å…¶ä½œä¸ºè‡ªèº«åˆ†æ•°çš„è®¡ç®—ä¾æ®ã€‚"
    };

    const TYPE_MAP = {
        "SB1": "kick", "SB2": "hat", "SB3": "shaker", "SB4": "chord", "SB5": "bass",
        "EB1": "snare", "EB2": "hat", "EB3": "clap", "EB4": "tom", "EB5": "bass", "EB6": "noise",
        "NG1": "noise", "NG2": "kick", "NG3": "hat", "NG4": "bass"
    };

    // --- Global Exposure ---
    window.startGame = startGame;
    window.buyCpu = buyCpu;
    window.sellSelectedItem = sellSelectedItem;
    window.rerollShop = rerollShop;
    window.runPlaybackSequence = runPlaybackSequence;
    window.skipPlayback = skipPlayback;
    window.closeResult = closeResult;
    window.nextLevel = nextLevel;
    window.retryLevel = retryLevel;
    window.openPoolConfig = openPoolConfig;
    window.showVictory = showVictory;
    window.showGameOver = showGameOver;
    window.clearAllItems = clearAllItems;
    window.showTooltip = showTooltip;
    window.hideTooltip = hideTooltip;
    window.debugSetGold = () => { const val = parseInt(document.getElementById('dbgGold').value); if(!isNaN(val)) { state.gold = val; updateUI(); } };
    window.debugSetTarget = () => { const val = parseInt(document.getElementById('dbgTarget').value); if(!isNaN(val)) { config.target = val; updateUI(); } };

    window.addEventListener('DOMContentLoaded', () => { initGrid(); });

    function showTooltip(e, key) {
        const tip = document.getElementById('tooltip');
        if(tip) {
            tip.style.display = 'block';
            tip.style.left = (e.clientX + 10) + 'px';
            tip.style.top = (e.clientY + 10) + 'px';
            tip.innerHTML = `<span class="tooltip-key">[${key}]</span>${DEFINITIONS[key] || ""}`;
        }
    }
    
    function hideTooltip() {
        const tip = document.getElementById('tooltip');
        if(tip) tip.style.display = 'none';
    }

    // --- Logic ---
    function startGame() {
        document.getElementById('startScreen').style.display = 'none';
        const starters = ["SB1", "EB1", "NG2"];
        state.inventory = [];
        state.ng1PermanentStacks = 0; 
        state.lives = 3;
        starters.forEach(id => addItemToInventory(id, 0)); 
        config.maxCpu = 12;
        applyLevelConfig(0);
        updateUI();
    }

    function addItemToInventory(id, price) {
        const data = DB.find(i => i.id === id);
        if(data) state.inventory.push({ uid: Date.now()+Math.random(), id: id, boughtPrice: price, data: data });
    }

    function applyLevelConfig(idx) {
        if (idx >= LEVEL_CONFIG.length) return;
        state.levelIndex = idx;
        const cfg = LEVEL_CONFIG[idx];
        config.target = cfg.target;
        config.activeTracks = cfg.tracks;
        state.cpuPurchasedRound = 0;
        state.roundBase = 10 + (idx * 2);
        if (cfg.poolAdds) {
            cfg.poolAdds.forEach(id => {
                if(!state.poolIds.includes(id)) state.poolIds.push(id);
                if (!state.poolEntryTimes[id]) state.poolEntryTimes[id] = idx;
            });
        }
        updateUI();
        initGrid(); 
        restorePlacedItems();
        rerollShop(); 
    }

    function updateUI() {
        document.getElementById('levelNum').innerText = `Level ${state.levelIndex + 1}`;
        document.getElementById('trackNum').innerText = config.activeTracks;
        document.getElementById('maxCpuText').innerText = `Max: ${config.maxCpu}`;
        document.getElementById('targetText').innerText = config.target;
        document.getElementById('goldText').innerText = state.gold;
        updateInventoryUI();
        updateCpuButton();
        updateCPU();
    }

    function updateGold(amount) { state.gold += amount; document.getElementById('goldText').innerText = state.gold; }
    function updateCpuButton() { const cost = 30 + (Math.min(state.cpuPurchasedRound, 3) * state.roundBase); document.getElementById('cpuPriceText').innerText = `${cost}G`; }
    function updateCPU() { const used = state.placedItems.reduce((a,b)=>a+b.data.cpu, 0); const pct = Math.min(100, (used/config.maxCpu)*100); const bar = document.getElementById('cpuBar'); if(bar) { bar.style.width = pct+"%"; bar.className = "cpu-fill " + (pct>=100?"danger":""); } document.getElementById('cpuText').innerText = `${used}`; }

    function initGrid() {
        const rh = document.querySelector('.timeline-header'); 
        if(rh) { rh.innerHTML = ''; for(let i=0; i<8; i++) { let d = document.createElement('div'); d.className = 'ruler-beat'; d.innerText = `${Math.floor(i/4)+1}.${(i%4)+1}`; rh.appendChild(d); } }
        const ta = document.getElementById('trackArea');
        if(ta) {
            ta.innerHTML = ''; 
            let ph = document.createElement('div'); ph.id = 'playhead'; ph.className = 'playhead'; ta.appendChild(ph);
            for(let i=0; i<TOTAL_TRACKS; i++) { 
                let tr = document.createElement('div'); tr.className = 'track'; 
                if (i >= config.activeTracks) tr.classList.add('locked'); 
                for(let t=0; t<TICKS; t++) { 
                    let c = document.createElement('div'); c.className = 'grid-cell'; 
                    c.onclick = () => tryPlaceItem(i, t); 
                    tr.appendChild(c); 
                } 
                ta.appendChild(tr); 
            }
        }
    }

    function tryPlaceItem(trackIdx, tick) { 
        if(state.isPlaying) return; 
        if (trackIdx >= config.activeTracks) { alert("è¯¥è½¨é“æœªè§£é”!"); return; } 
        if(!state.selectedInvItem) return; 
        const item = state.selectedInvItem; 
        const usedCpu = state.placedItems.reduce((a,b)=>a+b.data.cpu, 0); 
        if(usedCpu + item.data.cpu > config.maxCpu) { alert("CPU ä¸è¶³!"); return; } 
        if(tick + item.data.len > TICKS) return; 
        const collision = state.placedItems.some(p => p.track === trackIdx && !(tick >= p.start + p.data.len || tick + item.data.len <= p.start)); 
        if(collision) return; 
        const record = { id: Date.now(), data: item.data, track: trackIdx, start: tick };
        state.placedItems.push(record); 
        restorePlacedItems();
    }

    function clearAllItems() {
        if(state.isPlaying) return;
        if(!confirm("ç¡®å®šæ¸…ç©ºå½“å‰æ„ç­‘å—ï¼Ÿ(é“å…·ä¼šè¿”å›åº“å­˜)")) return;
        state.placedItems = [];
        restorePlacedItems();
    }

    function restorePlacedItems() {
        const ta = document.getElementById('trackArea');
        const items = ta.querySelectorAll('.placed-item');
        items.forEach(e => e.remove());
        state.placedItems.forEach(record => {
            const trEl = document.getElementsByClassName('track')[record.track];
            if (trEl) createPlacedElement(record, trEl);
        });
        updateRealTimeState();
    }

    function createPlacedElement(record, parent) {
        let el = document.createElement('div');
        el.className = 'placed-item';
        if (record.data.type) el.classList.add('type-' + record.data.type);
        el.style.left = (record.start/TICKS*100) + "%";
        el.style.width = (record.data.len/TICKS*100) + "%";
        el.style.backgroundColor = record.data.color;
        el.innerText = record.data.name;
        el.onclick = (e) => { 
            if(state.isPlaying) return;
            e.stopPropagation();
            state.selectedInvItem = null;
            updateInventoryUI(); 
            document.querySelectorAll('.placed-item').forEach(x => x.classList.remove('selected-placed'));
            el.classList.add('selected-placed');
            showDetail(record.data);
            document.getElementById('btnSellItem').style.display = 'none';
        };
        el.oncontextmenu = (e) => {
            if(state.isPlaying) return;
            e.preventDefault();
            el.remove();
            state.placedItems = state.placedItems.filter(x => x !== record);
            updateRealTimeState(); 
        };
        parent.appendChild(el);
        record.el = el;
    }

    function updateInventoryUI() {
        const list = document.getElementById('inventoryList'); list.innerHTML = ''; 
        state.inventory.forEach(item => { 
            let d = document.createElement('div'); d.className = 'inv-item'; 
            d.style.borderLeftColor = item.data.color; 
            if(state.selectedInvItem === item) d.classList.add('selected'); 
            if(state.isPlaying) d.classList.add('disabled'); 
            d.innerHTML = `<b style="color:${item.data.color}">${item.data.name}</b><div class="inv-meta"><span>CPU:${item.data.cpu}</span><span>Len:${item.data.len}</span></div>`; 
            d.onclick = () => { 
                if(state.isPlaying) return; 
                state.selectedInvItem = (state.selectedInvItem === item) ? null : item; 
                updateInventoryUI(); 
                showDetail(item.data);
                const btnSell = document.getElementById('btnSellItem');
                if (state.selectedInvItem) {
                    const sellPrice = item.boughtPrice === 0 ? 25 : Math.floor(item.boughtPrice * 0.25);
                    btnSell.innerText = `å‡ºå”® (${sellPrice}G)`;
                    btnSell.style.display = 'block';
                } else { btnSell.style.display = 'none'; }
            }; 
            list.appendChild(d); 
        });
    }

    // --- Audio V13.0 ---
    let visualInterval = null;
    let playbackStartTime = 0;
    let playbackTimer = null; 
    let bgSynths = {}; let itemSynths = {}; let audioInitialized = false;
    let isSkipping = false;
    let bgPlayer = null; let losePlayer = null; let effects = {};
    let fallbackLoop = null;

    async function initAudio() {
        if(audioInitialized) return;
        await Tone.start();
        
        bgPlayer = new Tone.Player({ url: "race_main_loop.mp3", fadeOut: 0.05 }).toDestination();
        losePlayer = new Tone.Player({ url: "race_lose_loop_120bpm.mp3", fadeOut: 0.05, volume: -3 }).toDestination();
        
        effects.filter = new Tone.Filter(20000, "lowpass").toDestination();
        effects.crusher = new Tone.BitCrusher(16).toDestination(); 
        effects.phaser = new Tone.Phaser({ frequency: 15, octaves: 5, baseFrequency: 1000, wet: 0 }).toDestination();
        
        bgPlayer.disconnect(); bgPlayer.connect(effects.filter);
        effects.filter.connect(effects.crusher);
        effects.crusher.connect(effects.phaser); 
        losePlayer.disconnect(); losePlayer.connect(effects.filter);

        itemSynths.sb1 = new Tone.MembraneSynth({ volume: 0 }).toDestination(); 
        itemSynths.sb2 = new Tone.MetalSynth({ frequency: 200, envelope: { decay: 0.2 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5, volume: -2 }).toDestination(); 
        itemSynths.sb3 = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { decay: 0.1 }, volume: -5 }).toDestination(); 
        itemSynths.eb1 = new Tone.NoiseSynth({ volume: -5, envelope: { decay: 0.2 } }).toDestination(); 
        itemSynths.eb2 = new Tone.MetalSynth({ frequency: 300, envelope: { decay: 0.05 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5, volume: -10 }).toDestination(); 
        itemSynths.eb3 = new Tone.NoiseSynth({ volume: -5, envelope: { attack: 0.01, decay: 0.3 } }).toDestination(); 
        itemSynths.eb4 = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 4, oscillator: { type: "sine" }, volume: -2 }).toDestination(); 
        itemSynths.eb6 = new Tone.MonoSynth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 }, volume: -5 }).toDestination(); 
        itemSynths.ng1 = new Tone.NoiseSynth({ noise: { type: "brown" }, envelope: { attack: 1, decay: 1, sustain: 1 }, volume: -10 }).toDestination(); 
        itemSynths.ng2 = new Tone.MetalSynth({ frequency: 800, harmonicity: 1.2, resonance: 800, modulationIndex: 20, envelope: { decay: 0.2 }, volume: -8 }).toDestination(); 
        itemSynths.ng3 = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, oscillator: { type: "sine" }, volume: -5 }).toDestination(); 
        itemSynths.ng4 = new Tone.MonoSynth({ volume: -5, oscillator: { type: "sawtooth" }, envelope: { attack: 0.2, decay: 0.5, sustain: 0 } }).toDestination(); 

        fallbackLoop = new Tone.Loop(time => {
            itemSynths.sb1.triggerAttackRelease("C1", "8n", time);
            itemSynths.sb2.triggerAttackRelease("32n", time + 0.25);
        }, "2n");

        try { await Promise.race([ Tone.loaded(), new Promise((_, r) => setTimeout(() => r("Timeout"), 3000)) ]); } catch(e) {}
        audioInitialized = true;
    }

    function getRhythm(len) {
        if(len===1) return [0];
        if(len===2) return [0, 0.5];
        if(len===4) return [0, 1, 2, 3]; 
        if(len===8) return [0, 2, 4, 6];
        return [0];
    }

    function configureBgmSegment() {
        let useBackHalf = false;
        if (state.lives === 1) { if (state.levelIndex < 3) useBackHalf = true; else useBackHalf = false; } 
        else { if (state.levelIndex < 3) useBackHalf = false; else useBackHalf = true; }
        const start = useBackHalf ? 16 : 0;
        if(bgPlayer) { bgPlayer.loopStart = start; bgPlayer.loopEnd = start + 16; }
        if(losePlayer) { losePlayer.loopStart = start; losePlayer.loopEnd = start + 16; }
        return start; 
    }

    function scheduleAudio() {
        if(!audioInitialized) return;
        Tone.Transport.cancel();
        Tone.Transport.stop();
        Tone.Transport.position = 0;

        const player = (state.lives === 1) ? losePlayer : bgPlayer;
        const other = (state.lives === 1) ? bgPlayer : losePlayer;
        if(other.state==="started") other.stop();
        
        const offset = configureBgmSegment();

        if(player.loaded) {
             Tone.Transport.schedule((t) => {
                 player.start(t, offset).stop(t + TOTAL_DURATION);
             }, 0);
        } else {
             fallbackLoop.start(0).stop(TOTAL_DURATION);
        }

        effects.filter.frequency.value = 20000;
        effects.crusher.bits.value = 16;
        effects.phaser.wet.value = 0;

        state.placedItems.forEach(item => {
            const start = item.start * TICK_DURATION;
            const duration = item.data.len * TICK_DURATION;
            const id = item.data.id;

            if (id === "SB1") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.sb1.triggerAttackRelease("C2", "8n", t), start+(p*0.5)));
            else if (id === "SB2") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.sb2.triggerAttackRelease("32n", t, 0.3), start+(p*0.5)));
            else if (id === "SB3") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.sb3.triggerAttackRelease("16n", t), start+(p*0.5)));
            else if (id === "SB4") {
                Tone.Transport.schedule(t => effects.filter.frequency.rampTo(400, 0.2, t), start);
                Tone.Transport.schedule(t => effects.filter.frequency.rampTo(20000, 0.2, t), start + duration);
            }
            else if (id === "SB5") {
                Tone.Transport.schedule(t => effects.phaser.wet.rampTo(1, 0.2, t), start);
                Tone.Transport.schedule(t => effects.phaser.wet.rampTo(0, 0.2, t), start + duration);
            }
            else if (id === "EB1") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.eb1.triggerAttackRelease("8n", t), start+(p*0.5)));
            else if (id === "EB2") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.eb2.triggerAttackRelease("32n", t), start+(p*0.5)));
            else if (id === "EB3") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.eb3.triggerAttackRelease("16n", t), start+(p*0.5)));
            else if (id === "EB4") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.eb4.triggerAttackRelease("G2", "8n", t), start+(p*0.5)));
            else if (id === "EB5") {
                Tone.Transport.schedule(t => effects.crusher.bits.rampTo(4, 0.1, t), start);
                Tone.Transport.schedule(t => effects.crusher.bits.rampTo(16, 0.1, t), start + duration);
            }
            else if (id === "EB6") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.eb6.triggerAttackRelease("C5", "32n", t), start+(p*0.5)));
            else if (id === "NG1") Tone.Transport.schedule(t => itemSynths.ng1.triggerAttackRelease(duration, t), start); 
            else if (id === "NG2") getRhythm(item.data.len).forEach(p => Tone.Transport.schedule(t => itemSynths.ng2.triggerAttackRelease("16n", t), start+(p*0.5)));
            else if (id === "NG3") Tone.Transport.schedule(t => itemSynths.ng3.triggerAttackRelease("C5", "16n", t), start);
            else if (id === "NG4") Tone.Transport.schedule(t => itemSynths.ng4.triggerAttackRelease("16n", t), start);
        });
    }

    async function runPlaybackSequence() {
        if(state.isPlaying) return;
        state.isPlaying = true;
        isSkipping = false;
        
        const btn = document.getElementById('mainSubmitBtn'); 
        btn.disabled = true; btn.innerText = "Running..."; 
        document.getElementById('mainContainer').classList.add('playing-lock');
        document.getElementById('skipOverlay').style.display = 'flex'; 

        try {
            await initAudio();
            Tone.Transport.stop(); Tone.Transport.cancel(); Tone.Draw.cancel(); 
            
            scheduleAudio(); 
            Tone.Transport.start(); 
            
        } catch(e) { console.log("Audio error", e); }

        startVisualEngine(false);
        if (playbackTimer) clearTimeout(playbackTimer);
        playbackTimer = setTimeout(finishPlayback, TOTAL_DURATION * 1000 + 150);
    }

    function startVisualEngine(fastForward) {
        playbackStartTime = Date.now();
        const playhead = document.getElementById('playhead');
        if(playhead) { playhead.style.display = 'block'; playhead.style.left = '0%'; }
        if (visualInterval) clearInterval(visualInterval);

        const duration = fastForward ? 0.8 : TOTAL_DURATION; 

        visualInterval = setInterval(() => {
            const realElapsed = (Date.now() - playbackStartTime) / 1000; 
            const progress = realElapsed / duration;
            
            if(playhead) playhead.style.left = (progress * 100) + "%";

            const simTime = fastForward ? progress * TOTAL_DURATION : (Tone.Transport.seconds || realElapsed);

            state.placedItems.forEach(item => {
                const start = item.start * TICK_DURATION;
                const end = start + (item.data.len * TICK_DURATION);
                if (item.el) {
                    if (simTime >= start && simTime < end) {
                        if(!item.el.classList.contains('playing-active')) item.el.classList.add('playing-active');
                    } else {
                        if(item.el.classList.contains('playing-active')) item.el.classList.remove('playing-active');
                    }
                }
            });
            
            if (realElapsed >= duration) {
                clearInterval(visualInterval);
                if (fastForward) finishPlayback();
            }
        }, 16);
    }

    function skipPlayback() {
        if (isSkipping) return;
        isSkipping = true;
        
        Tone.Transport.stop(); 
        Tone.Transport.cancel(); 
        if(bgPlayer) { bgPlayer.stop(); bgPlayer.disconnect(); }
        if(losePlayer) { losePlayer.stop(); losePlayer.disconnect(); }
        if(fallbackLoop) fallbackLoop.stop();
        Tone.Draw.cancel(); 

        if (playbackTimer) clearTimeout(playbackTimer);
        try { const noise = new Tone.Noise("pink").toDestination(); noise.start(); noise.stop("+0.8"); } catch(e){}
        startVisualEngine(true);
    }

    function finishPlayback() {
        Tone.Transport.stop();
        Tone.Transport.cancel();
        if(bgPlayer) { bgPlayer.stop(); try{bgPlayer.connect(effects.filter);}catch(e){} }
        if(losePlayer) { losePlayer.stop(); try{losePlayer.connect(effects.filter);}catch(e){} }
        if(fallbackLoop) fallbackLoop.stop();
        
        if (visualInterval) clearInterval(visualInterval);
        document.querySelectorAll('.placed-item').forEach(el => el.classList.remove('playing-active'));
        const playhead = document.getElementById('playhead');
        if(playhead) playhead.style.display = 'none';
        document.getElementById('skipOverlay').style.display = 'none';
        
        state.isPlaying = false; 
        document.getElementById('mainContainer').classList.remove('playing-lock'); 
        document.getElementById('mainSubmitBtn').disabled = false; 
        document.getElementById('mainSubmitBtn').innerText = "Submit / ç»“ç®—"; 
        
        const currentNg1Count = state.placedItems.filter(p => p.data.id === "NG1").length;
        if (currentNg1Count > 0) { state.ng1PermanentStacks += currentNg1Count; }
        
        const results = calculateLogic();
        let totalScore = 0;
        results.forEach(r => totalScore += (r.base + r.bonus) * r.mult * r.finalMultiplier);
        
        showResult(currentNg1Count, Math.floor(totalScore));
    }

    function renderCampaignStatus() {
        let hearts = "";
        for(let i=0; i<3; i++) { if(i < state.lives) hearts += "â¤ï¸"; else hearts += "ğŸ’”"; }
        let dots = "";
        for(let i=0; i<LEVEL_CONFIG.length; i++) {
            let cls = "status-dot";
            if(i < state.levelIndex) cls += " done";
            if(i === state.levelIndex) cls += " current done";
            dots += `<div class="${cls}"></div>`;
        }
        return `<div class="status-item"><span class="status-hearts">${hearts}</span></div><div class="status-item" style="margin-left:20px;"><span>è¿›åº¦:</span><div class="status-dots">${dots}</div></div>`;
    }

    function showResult(ng1Added, totalScore) {
        const isWin = totalScore >= config.target;
        const outcomeEl = document.getElementById('resOutcome');
        const nextBtn = document.getElementById('nextLevelBtn');
        const finishBtn = document.getElementById('finishGameBtn');
        const retryBtn = document.getElementById('retryLevelBtn');
        const dieBtn = document.getElementById('dieBtn');
        const info = document.getElementById('resRewardInfo');
        const statusContainer = document.getElementById('campaignStatusContainer');
        
        nextBtn.style.display = 'none';
        finishBtn.style.display = 'none';
        retryBtn.style.display = 'none';
        dieBtn.style.display = 'none';

        if (!isWin) state.lives--;
        statusContainer.innerHTML = renderCampaignStatus();
        
        if(isWin) {
            outcomeEl.innerText = "æŒ‘æˆ˜æˆåŠŸ"; outcomeEl.style.color = "var(--highlight)";
            const rw = LEVEL_CONFIG[state.levelIndex].reward;
            state.pendingReward = rw;
            info.innerText = `èµé‡‘: +${rw}G`;
            if (state.levelIndex >= LEVEL_CONFIG.length - 1) finishBtn.style.display = "block"; 
            else nextBtn.style.display = "block";
        } else {
            outcomeEl.innerText = "æŒ‘æˆ˜å¤±è´¥"; outcomeEl.style.color = "var(--lose-color)";
            const rw = Math.floor(LEVEL_CONFIG[state.levelIndex].reward * 0.6);
            state.pendingReward = rw;
            info.innerText = `æŠšæ¤é‡‘: +${rw}G`;
            if(state.lives <= 0) dieBtn.style.display = "block";
            else retryBtn.style.display = "block";
        }
        
        let html = `<table class="result-table"><thead><tr>
            <th>é“å…·</th><th>åŸºç¡€</th><th>æ¡ä»¶</th><th>å€ç‡</th><th>æœ€ç»ˆ</th><th>å¤‡æ³¨</th>
        </tr></thead><tbody>`;
        const results = calculateLogic();
        results.forEach(r => {
            const score = Math.floor((r.base + r.bonus) * r.mult * r.finalMultiplier);
            let notesHTML = "";
            if(r.bonus > 0) notesHTML += `<span class="buff-tag tag-${r.record.data.type}">${r.record.data.name} æ•ˆæœ +${r.bonus}</span>`;
            if(r.buffsReceived.length > 0) notesHTML += r.buffsReceived.map(b => `<span class="buff-tag tag-${b.type}">${b.text}</span>`).join("");
            html += `<tr>
                <td>${r.record.data.name}</td>
                <td>${r.base}</td>
                <td>${r.bonus.toFixed(0)}</td>
                <td>x${(r.mult * r.finalMultiplier).toFixed(2)}</td>
                <td class="score-val">${score}</td>
                <td style="font-size:10px; color:#aaa;">${notesHTML}</td>
            </tr>`;
        });
        if(ng1Added > 0) html += `<tr><td colspan="6" style="text-align:center; color:#ffd700;">NG1 å……èƒ½ +${ng1Added} å±‚</td></tr>`;
        html += `</tbody></table>`;
        
        document.getElementById('resTableContainer').innerHTML = html;
        document.getElementById('resTotalScore').innerText = Math.floor(totalScore);
        document.getElementById('resTargetDisplay').innerText = config.target;
        document.getElementById('resultModal').style.display = 'flex';
    }

    function showVictory() { document.getElementById('victoryModal').style.display = 'flex'; }
    function showGameOver() { document.getElementById('gameOverModal').style.display = 'flex'; }
    function closeResult() { document.getElementById('resultModal').style.display = 'none'; }
    function nextLevel() { updateGold(state.pendingReward); const next = state.levelIndex + 1; document.getElementById('resultModal').style.display = 'none'; if(next >= LEVEL_CONFIG.length) showVictory(); else applyLevelConfig(next); }
    function retryLevel() { updateGold(state.pendingReward); document.getElementById('resultModal').style.display = 'none'; updateUI(); rerollShop(); }
    function sellSelectedItem() { if (!state.selectedInvItem) return; const item = state.selectedInvItem; if(item.id === "NG1" && state.ng1PermanentStacks > 0) { applyNG1Discount(state.ng1PermanentStacks); state.ng1PermanentStacks = 0; } state.placedItems = state.placedItems.filter(p => p.data.id !== item.id); restorePlacedItems(); const price = item.boughtPrice === 0 ? 25 : Math.floor(item.boughtPrice * 0.25); updateGold(price); state.inventory = state.inventory.filter(x => x !== item); state.selectedInvItem = null; updateInventoryUI(); document.getElementById('btnSellItem').style.display = 'none'; }
    function applyNG1Discount(count) { const minDisc = 0.05 * count; const maxDisc = 0.10 * count; let msg = `NG1 çˆ†å‘! ${count}å±‚å……èƒ½ï¼Œå…¨åœºéª¨æŠ˜!`; state.currentShopItems.forEach(item => { if(!item.sold) { let extra = minDisc + Math.random() * (maxDisc - minDisc); const minPrice = Math.floor(item.data.price * 0.1); let newPrice = Math.floor(item.price * (1 - extra)); if (newPrice < minPrice) newPrice = minPrice; item.price = newPrice; item.isDiscount = true; item.discountPercent += Math.round(extra * 100); } }); alert(msg); renderShopFromState(); }
    function buyCpu() { const cost = 30 + (Math.min(state.cpuPurchasedRound, 3) * state.roundBase); if(state.gold >= cost) { updateGold(-cost); config.maxCpu++; state.cpuPurchasedRound++; updateUI(); updateCPU(); } else { alert("No Gold"); } }
    
    // V16.0 Logic: Unique + Decay + Correct Discount
    function rerollShop() { 
        if(state.isPlaying) return; 
        const isManual = (event && event.target && event.target.id === 'btnReroll'); 
        if (isManual) { if(state.gold < 10) { alert("é‡‘å¸ä¸è¶³"); return; } updateGold(-10); } 
        state.currentShopItems = []; 
        // 1. Filter Valid Items from Pool & Remove Owned
        let candidates = DB.filter(i => state.poolIds.includes(i.id) && !state.inventory.some(inv => inv.id === i.id)); 
        
        // 2. Shuffle candidates to ensure randomness when picking from same rarity
        candidates.sort(() => Math.random() - 0.5);

        for(let i=0; i<4; i++) { 
            if(candidates.length === 0) break; 
            const rand = Math.random(); 
            let rarityTarget = 1; if (rand > 0.6) rarityTarget = 2; if (rand > 0.9) rarityTarget = 3; 
            
            // Find item in pool
            let pool = candidates.filter(x => x.rarity === rarityTarget); 
            if (pool.length === 0) pool = candidates; // Fallback
            
            const itemBase = pool[0]; // Pick first (already shuffled)
            
            // IMPORTANT: Remove from candidates so it doesn't show up again in this roll
            candidates = candidates.filter(x => x.id !== itemBase.id); 
            
            const variance = Math.floor(Math.random() * 11) - 5; 
            let finalPrice = itemBase.price + variance; 
            
            // Discount
            const entryRound = state.poolEntryTimes[itemBase.id] || 0; 
            const roundsInPool = state.levelIndex - entryRound; 
            const discountChance = Math.min(0.5, 0.2 + (roundsInPool * 0.1)); 
            let isDiscount = Math.random() < discountChance; 
            let discountPercent = 0; 
            if(isDiscount) { 
                const maxOff = Math.min(0.5, 0.1 + (roundsInPool * 0.1));
                const minOff = 0.1;
                const actualOff = minOff + Math.random() * (maxOff - minOff);
                finalPrice = Math.floor(finalPrice * (1 - actualOff)); 
                discountPercent = Math.round(actualOff * 100); 
            } 
            state.currentShopItems.push({ data: itemBase, price: finalPrice, isDiscount: isDiscount, discountPercent: discountPercent, sold: false }); 
        } 
        renderShopFromState(); 
    }
    
    function renderShopFromState() { const list = document.getElementById('shopList'); list.innerHTML = ''; state.currentShopItems.forEach(item => { let d = document.createElement('div'); d.className = 'shop-item'; d.onclick = () => { if(!state.isPlaying) showDetail(item.data); }; let btn = document.createElement('button'); btn.className = "btn-buy"; if (item.sold) { btn.disabled = true; btn.innerText = "å·²è´­"; } else { btn.innerHTML = `${item.price}G`; btn.onclick = (e) => { e.stopPropagation(); if(state.gold>=item.price){ updateGold(-item.price); addItemToInventory(item.data.id, item.price); item.sold=true; updateInventoryUI(); renderShopFromState(); } else { alert("No Gold"); } }; } let html = `<div class="shop-row-top"><b style="color:${item.data.color}">${item.data.name}</b></div><div class="shop-row-btm"><span>CPU:${item.data.cpu}</span><span>Len:${item.data.len}</span></div>`; if (item.isDiscount) html += `<div class="discount-tag">-${item.discountPercent}%</div>`; d.innerHTML = html; d.querySelector('.shop-row-top').appendChild(btn); list.appendChild(d); }); }
    
    // V18.1 Logic: NG4 Fix (Base+Sucked)*1.5, EB2 125%, EB5 Global
    function calculateLogic() { 
        const items = state.placedItems; 
        const sorted = [...items].sort((a,b) => a.start - b.start); 
        let output = sorted.map(p => ({ record: p, base: p.data.base, bonus: 0, mult: 1.0, finalMultiplier: 1.0, triggered: false, buffsReceived: [], buffsGiven: [], forceStrong: false })); 
        
        let globalWeakIsStrong = false; 
        let globalGapMult = 1;          
        output.forEach(entry => { 
            const d = entry.record.data; 
            const s = entry.record.start; 
            const isNaturalStrong = (s % 8 === 0); 
            if (d.id === "SB5" && isNaturalStrong) { globalWeakIsStrong = true; entry.triggered = true; } 
            if (d.id === "EB5") { globalGapMult = 2; entry.triggered = true; } // EB5 Global
        }); 
        
        let strongBeatCount = 0; 
        let sb4Triggered = false; 
        output.forEach((entry, idx) => { 
            const p = entry.record; const d = p.data; const s = p.start; const e = s + d.len; 
            let isStrong = (s % 8 === 0) || (globalWeakIsStrong && s % 4 === 0) || entry.forceStrong; 
            if (isStrong && (d.id.startsWith("SB") || d.id.startsWith("NG"))) strongBeatCount++; 
            const trackItems = output.filter(x => x.record.track === p.track); 
            const tIdx = trackItems.indexOf(entry); 
            const prev = tIdx > 0 ? trackItems[tIdx-1] : null; 
            const next = tIdx < trackItems.length-1 ? trackItems[tIdx+1] : null; 
            const concurrent = output.filter(x => x !== entry && x.record.start === s); 
            const calcGap = (t1, t2) => Math.max(0, t2 - t1) * globalGapMult; 
            
            if (d.id === "SB1") { if (isStrong) { entry.bonus += 10; entry.triggered = true; } } 
            else if (d.id === "SB2") { if (concurrent.length > 0) concurrent.forEach(t => { t.mult += 0.5; t.buffsReceived.push({text:`[${d.name}] +50%`, type:d.type}); }); if (isStrong && concurrent.length > 0) { concurrent.forEach(t => { t.mult += 0.25; t.buffsReceived.push({text:`[${d.name}å¼ºæ‹] +25%`, type:d.type}); }); entry.triggered = true; } } 
            else if (d.id === "SB3") { if (next) { next.mult += 1.0; next.buffsReceived.push({text:`[${d.name}] +100%`, type:d.type}); } if (isStrong && next) { next.forceStrong = true; entry.triggered = true; } } 
            else if (d.id === "SB4") { if (isStrong && strongBeatCount > 5 && !sb4Triggered) { sb4Triggered = true; entry.triggered = true; for (let i = idx + 1; i < output.length; i++) { const target = output[i]; const tS = target.record.start; const tIsStrong = (tS % 8 === 0) || (globalWeakIsStrong && tS % 4 === 0) || target.forceStrong; if (tIsStrong && target.record.data.type === "score") { target.finalMultiplier *= 1.5; target.buffsReceived.push({text:`[${d.name}] x1.5(ç‹¬ç«‹)`, type:d.type}); } } } } 
            else if (d.id === "EB1") { if (prev) { const gap = calcGap(prev.record.start + prev.record.data.len, s); if (gap >= 4) { entry.bonus += 20; entry.triggered = true; } } } 
            else if (d.id === "EB2") { if (next) { let boost = 0.35; next.mult += 0.35; next.buffsReceived.push({text:`[${d.name}] +35%`, type:d.type}); const gap = calcGap(e, next.record.start); if (gap > 0) { let extra = Math.min(1.25, gap * 0.125); next.mult += extra; next.buffsReceived.push({text:`[${d.name}ç©ºæ‹] +${(extra*100).toFixed(0)}%`, type:d.type}); entry.triggered = true; } } } 
            else if (d.id === "EB3") { if (concurrent.length > 0) concurrent.forEach(t => { if(t.record.data.type==="score") t.bonus += 10; }); let gapTotal = 0; if(prev) gapTotal += calcGap(prev.record.start+prev.record.data.len, s); if(next) { gapTotal += calcGap(e, next.record.start); } else { gapTotal += calcGap(e, TICKS); } if (gapTotal > 0) { let extraMult = Math.min(2.4, gapTotal * 0.075); concurrent.forEach(t => { if(t.record.data.type === "score") { t.mult += extraMult; t.buffsReceived.push({text:`[${d.name}] +${(extraMult*100).toFixed(1)}%`, type:d.type}); } }); entry.triggered = true; } } 
            else if (d.id === "EB4") { let totalSpace = s * 3; let occupied = 0; items.forEach(it => { let iS = it.start; let iE = it.start + it.data.len; if (iE <= s) occupied += it.data.len; else if (iS < s) occupied += (s - iS); }); let empty = Math.max(0, totalSpace - occupied) * globalGapMult; if (empty > 0) { let boost = empty * 0.05; entry.mult += boost; entry.buffsReceived.push({text:`[ç©ºæ‹] +${(boost*100).toFixed(0)}%`, type:d.type}); entry.triggered = true; } } 
            else if (d.id === "EB6") { let dur = e - s; let totalSpace = dur * 3; let occupied = 0; items.forEach(it => { if (it === p) return; let iS = it.start; let iE = it.start + it.data.len; let overlap = Math.max(0, Math.min(e, iE) - Math.max(s, iS)); occupied += overlap; }); occupied += dur; let empty = Math.max(0, totalSpace - occupied) * globalGapMult; if (empty > 0) { let boost = empty * 0.05; entry.mult += boost; entry.triggered = true; } } 
            else if (d.id === "NG2") { if (concurrent.length > 0) { entry.bonus += 10; entry.triggered = true; } } 
            else if (d.id === "NG3") { if (prev) { prev.mult += 0.35; prev.buffsReceived.push({text:`[${d.name}] +35%`, type:d.type}); } if (next) { next.mult += 0.35; next.buffsReceived.push({text:`[${d.name}] +35%`, type:d.type}); } if (concurrent.length === 0) { if (prev) { prev.mult += 0.35; prev.buffsReceived.push({text:`[${d.name}ç‹¬å¥] +35%`, type:d.type}); } if (next) { next.mult += 0.35; next.buffsReceived.push({text:`[${d.name}ç‹¬å¥] +35%`, type:d.type}); } entry.triggered = true; } } 
        }); 
        
        output.forEach(entry => { 
            const d = entry.record.data; 
            if (d.id === "NG4") { 
                const s = entry.record.start; 
                const concurrent = output.filter(x => x !== entry && x.record.start === s); 
                let suckedScore = 0; 
                concurrent.forEach(t => { 
                    if (t.record.data.type === "score") { 
                        let current = (t.base + t.bonus) * t.mult * t.finalMultiplier; 
                        t.finalMultiplier *= 0.5; 
                        t.buffsReceived.push({text:`[${d.name}] å‡åŠ`, type:d.type}); 
                        let now = (t.base + t.bonus) * t.mult * t.finalMultiplier; 
                        suckedScore += (current - now); 
                    } 
                }); 
                // V18.0 NG4 Fix: (Base+Sucked)*1.5
                if (suckedScore > 0) { 
                    // Current base is 40. We want Total = (40 + sucked) * 1.5.
                    // Current formula: Total = (40 + bonus) * mult.
                    // So 40 + bonus = 60 + 1.5*sucked
                    // bonus = 20 + 1.5*sucked
                    entry.bonus += 20 + (suckedScore * 1.5); 
                    entry.buffsReceived.push({text:`å¸å– +${(suckedScore * 1.5).toFixed(0)}`, type:d.type}); 
                    entry.triggered = true; 
                }  
            } 
        }); 
        return output; 
    }
    function updateRealTimeState() { updateCPU(); const results = calculateLogic(); state.placedItems.forEach(p => { const res = results.find(r => r.record === p); p.el.classList.remove('glowing-score', 'glowing-support', 'glowing-engine'); if(res && res.triggered) { if (p.data.type === "score") p.el.classList.add('glowing-score'); else if (p.data.type === "support") p.el.classList.add('glowing-support'); else if (p.data.type === "engine") p.el.classList.add('glowing-engine'); } }); }
    function openPoolConfig() { if(state.isPlaying) return; const grid = document.getElementById('poolGrid'); grid.innerHTML = ''; DB.forEach(item => { let d = document.createElement('div'); d.className = 'card ' + (state.poolIds.includes(item.id) ? 'active' : ''); d.innerHTML = item.name; d.onclick = () => { if(state.poolIds.includes(item.id)) { state.poolIds = state.poolIds.filter(x=>x!==item.id); d.classList.remove('active'); } else { state.poolIds.push(item.id); d.classList.add('active'); } }; grid.appendChild(d); }); document.getElementById('poolModal').style.display = 'flex'; }
    function showDetail(item) { document.getElementById('detailTitle').innerText = item.name; document.getElementById('detailTitle').style.color = item.color; document.getElementById('detailMeta').innerHTML = `<span>CPU: ${item.cpu}</span><span>é•¿åº¦: ${item.len}æ ¼</span><span>åŸºç¡€åˆ†: ${item.base}</span>`; let desc = item.desc; if (item.id === "NG1") { desc += `<br><span style="color:#ffd700; font-weight:bold;">[å½“å‰å·²ç´¯è®¡å……èƒ½: ${state.ng1PermanentStacks} å±‚]</span>`; } for (const key in DEFINITIONS) { const regex = new RegExp(`\\[${key}\\]`, "g"); desc = desc.replace(regex, `<span class="tooltip-ref" onmouseenter="showTooltip(event, '${key}')" onmouseleave="hideTooltip()">[${key}]</span>`); } document.getElementById('detailContent').innerHTML = desc; }
    function updateConfig() { config.maxCpu = parseInt(document.getElementById('maxCpuInput').value); config.target = parseInt(document.getElementById('targetInput').value); updateRealTimeState(); updateCPU(); }
</script>
</body>
</html>